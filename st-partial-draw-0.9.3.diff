diff -u st/st.c st-patched/st.c
--- st/st.c	2025-10-05 01:53:11.167987562 +0200
+++ st-patched/st.c	2025-10-05 14:19:46.947761628 +0200
@@ -116,6 +116,8 @@
 	Line *line;   /* screen */
 	Line *alt;    /* alternate screen */
 	int *dirty;   /* dirtyness of lines */
+	int *dirtystart;   /* beginning of dirty segemnt */
+	int *dirtyend;     /* end of dirty segment */
 	TCursor c;    /* cursor */
 	int ocx;      /* old cursor col */
 	int ocy;      /* old cursor row */
@@ -432,13 +434,14 @@
 
 	if (sel.snap != 0)
 		sel.mode = SEL_READY;
-	tsetdirt(sel.nb.y, sel.ne.y);
+	tsetdirtrect(sel.nb.x, sel.nb.y, sel.ne.x, sel.ne.y);
+	/* tsetdirt(sel.nb.y, sel.ne.y); */
 }
 
 void
 selextend(int col, int row, int type, int done)
 {
-	int oldey, oldex, oldsby, oldsey, oldtype;
+	int oldey, oldex, oldsbx, oldsby, oldsex, oldsey, oldtype;
 
 	if (sel.mode == SEL_IDLE)
 		return;
@@ -449,7 +452,9 @@
 
 	oldey = sel.oe.y;
 	oldex = sel.oe.x;
+	oldsbx = sel.nb.x;
 	oldsby = sel.nb.y;
+	oldsex = sel.ne.x;
 	oldsey = sel.ne.y;
 	oldtype = sel.type;
 
@@ -459,7 +464,8 @@
 	sel.type = type;
 
 	if (oldey != sel.oe.y || oldex != sel.oe.x || oldtype != sel.type || sel.mode == SEL_EMPTY)
-		tsetdirt(MIN(sel.nb.y, oldsby), MAX(sel.ne.y, oldsey));
+		tsetdirtrect(MIN(sel.nb.x, oldsbx), MIN(sel.nb.y, oldsby), MAX(sel.ne.x, oldsex), MAX(sel.ne.y, oldsey));
+		/* tsetdirt(MIN(sel.nb.y, oldsby), MAX(sel.ne.y, oldsey)); */
 
 	sel.mode = done ? SEL_IDLE : SEL_READY;
 }
@@ -643,7 +649,8 @@
 		return;
 	sel.mode = SEL_IDLE;
 	sel.ob.x = -1;
-	tsetdirt(sel.nb.y, sel.ne.y);
+	tsetdirtrect(sel.nb.x, sel.nb.y, sel.ne.x, sel.ne.y);
+	/* tsetdirt(sel.nb.y, sel.ne.y); */
 }
 
 void
@@ -968,8 +975,11 @@
 	LIMIT(top, 0, term.row-1);
 	LIMIT(bot, 0, term.row-1);
 
-	for (i = top; i <= bot; i++)
+	for (i = top; i <= bot; i++) {
 		term.dirty[i] = 1;
+		term.dirtystart[i] = 0;
+		term.dirtyend[i] = term.col - 1;
+	}
 }
 
 void
@@ -980,7 +990,8 @@
 	for (i = 0; i < term.row-1; i++) {
 		for (j = 0; j < term.col-1; j++) {
 			if (term.line[i][j].mode & attr) {
-				tsetdirt(i, i);
+				tsetdirtcol(j, i);
+				/* tsetdirt(i, i); */
 				break;
 			}
 		}
@@ -988,6 +999,56 @@
 }
 
 void
+tsetdirtcol(int x, int y) {
+	LIMIT(y, 0, term.row-1);
+	LIMIT(x, 0, term.col-1);
+
+	term.dirty[y] = 1;
+	if(x < term.dirtystart[y] || term.dirtystart[y] == -1) {
+		term.dirtystart[y] = x;
+	}
+	if(x > term.dirtyend[y] || term.dirtyend[y] == -1) {
+		term.dirtyend[y] = x;
+	}
+}
+
+void
+tsetdirtrange(int x1, int x2, int y) {
+	int i;
+
+	LIMIT(y,  0, term.row-1);
+	LIMIT(x1, 0, term.col-1);
+	LIMIT(x2, 0, term.col-1);
+	if(x1 > x2) {
+		i = x2;
+		x2 = x1;
+		x1 = i;
+	}
+
+	term.dirty[y] = 1;
+	if(term.dirtystart[y] == -1) {
+		term.dirtystart[y] = x1;
+		term.dirtyend[y] = x2;
+		return;
+	}
+	if(x1 < term.dirtystart[y]) {
+		term.dirtystart[y] = x1;
+	}
+	if(x2 > term.dirtyend[y]) {
+		term.dirtyend[y] = x2;
+	}
+}
+
+void
+tsetdirtrect(int x1, int y1, int x2, int y2) {
+	int i;
+
+	for (i = y1; i <= y2; i++) {
+		tsetdirtrange(x1, x2, i);
+	}
+}
+
+void
 tfulldirt(void)
 {
 	tsetdirt(0, term.row-1);
@@ -1033,6 +1094,11 @@
 		tclearregion(0, 0, term.col-1, term.row-1);
 		tswapscreen();
 	}
+
+	for(i = 0; i < term.row; ++i) {
+		term.dirty[i] = 0;
+		term.dirtystart[i] = term.dirtyend[i] = -1;
+	}
 }
 
 void
@@ -1215,7 +1281,8 @@
 		term.line[y][x-1].mode &= ~ATTR_WIDE;
 	}
 
-	term.dirty[y] = 1;
+	tsetdirtcol(x, y);
+	/* tsetdirt(y, y); */
 	term.line[y][x] = *attr;
 	term.line[y][x].u = u;
 }
@@ -1236,8 +1303,9 @@
 	LIMIT(y1, 0, term.row-1);
 	LIMIT(y2, 0, term.row-1);
 
+	tsetdirtrect(x1, y1, x2, y2);
+	/* tsetdirt(y1, y2); */
 	for (y = y1; y <= y2; y++) {
-		term.dirty[y] = 1;
 		for (x = x1; x <= x2; x++) {
 			gp = &term.line[y][x];
 			if (selected(x, y))
@@ -1264,6 +1332,7 @@
 	line = term.line[term.c.y];
 
 	memmove(&line[dst], &line[src], size * sizeof(Glyph));
+	tsetdirtrange(dst, src, term.c.y);
 	tclearregion(term.col-n, term.c.y, term.col-1, term.c.y);
 }
 
@@ -1281,6 +1350,7 @@
 	line = term.line[term.c.y];
 
 	memmove(&line[dst], &line[src], size * sizeof(Glyph));
+	tsetdirtrange(dst, src, term.c.y);
 	tclearregion(src, term.c.y, dst - 1, term.c.y);
 }
 
@@ -2603,8 +2673,16 @@
 	term.line = xrealloc(term.line, row * sizeof(Line));
 	term.alt  = xrealloc(term.alt,  row * sizeof(Line));
 	term.dirty = xrealloc(term.dirty, row * sizeof(*term.dirty));
+	/* allocate dirtystart/end buffers */
+	term.dirtystart = xrealloc(term.dirtystart, row * sizeof(*term.dirtystart));
+	term.dirtyend = xrealloc(term.dirtyend, row * sizeof(*term.dirtyend));
 	term.tabs = xrealloc(term.tabs, col * sizeof(*term.tabs));
 
+	for(i = 0; i < row; ++i) {
+		term.dirtystart[i] = term.dirtyend[i] = -1;
+		term.dirty[i] = 1;
+	}
+
 	/* resize each row to new width, zero-pad if needed */
 	for (i = 0; i < minrow; i++) {
 		term.line[i] = xrealloc(term.line[i], col * sizeof(Glyph));
@@ -2656,14 +2734,20 @@
 void
 drawregion(int x1, int y1, int x2, int y2)
 {
-	int y;
+	int y, start, end;
 
 	for (y = y1; y < y2; y++) {
-		if (!term.dirty[y])
-			continue;
-
-		term.dirty[y] = 0;
-		xdrawline(term.line[y], x1, y, x2);
+		if (term.dirty[y]) {
+			start = term.dirtystart[y];
+			end = term.dirtyend[y];
+			if (start == -1) {  /* Fallback to full if no col tracking */
+				start = x1;
+				end = x2 - 1;
+			}
+			xdrawline(term.line[y], start, y, end + 1);
+			term.dirtystart[y] = term.dirtyend[y] = -1;
+			term.dirty[y] = 0;
+		}
 	}
 }
 
diff -u st/st.h st-patched/st.h
--- st/st.h	2025-10-05 01:53:11.167987562 +0200
+++ st-patched/st.h	2025-10-05 01:57:41.325507996 +0200
@@ -90,6 +90,9 @@
 void tnew(int, int);
 void tresize(int, int);
 void tsetdirtattr(int);
+void tsetdirtcol(int, int); /* mark single cell as dirty */
+void tsetdirtrange(int, int, int); /* mark from X to X in a line as dirty */
+void tsetdirtrect(int, int, int, int); /* mark a rectangle as dirty */
 void ttyhangup(void);
 int ttynew(const char *, char *, const char *, char **);
 size_t ttyread(void);
diff -u st/x.c st-patched/x.c
--- st/x.c	2025-10-05 01:53:11.167987562 +0200
+++ st-patched/x.c	2025-10-05 14:00:32.439134902 +0200
@@ -1651,6 +1651,8 @@
 int
 xstartdraw(void)
 {
+	if (IS_SET(MODE_VISIBLE))
+		XCopyArea(xw.dpy, xw.win, xw.buf, dc.gc, 0, 0, win.w, win.h, 0, 0);
 	return IS_SET(MODE_VISIBLE);
 }
 
